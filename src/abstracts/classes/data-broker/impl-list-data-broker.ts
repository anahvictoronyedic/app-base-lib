import { Observable, Subject, Subscription,concat, EMPTY, from, map, switchMap, of, merge } from "rxjs";
import { ObjectUtils, OBJ_MODIFY_APPROACH } from "../../../utils/object-utils";
import { PaginatedDataManager } from "../../../utils/paginated-data-manager";
import { CRUD } from "../../enums/common";
import { DataBrokerEvent } from "../../interfaces/data-broker/data-broker";
import { ListDataBroker, ListDataBrokerConfig, ListDataBrokerCRUDUpdate, ListDataBrokerLoadOneOptions, ListDataBrokerLoadOptions, 
    ListDataBrokerResult, ListDataBrokerUpdate } from "../../interfaces/data-broker/list-data-broker";
import { DATA_COMPARATOR } from "../../types/common";

/**
 * An abstract implementation of the ListDataBroker interface that does some heavy lifting by taking care of :
 * 
 * 1. in-mem list data storage
 * 2. reflection of crud updates on the in-mem data for consistency
 * 3. providing an rxjs subject through which crud updates can be supplied.
 * 4. caching for performance sake
 * 5. concrete implementation of streamOne() method
 * 
 * @type U an unnormalized data in the list of data
 * @type D a normalized data in the list of data
 * @type EV_Type the event generated by the child side of the data broker.
 */
export abstract class ImplListDataBroker<U,D, EV_Type> implements ListDataBroker<U,D,EV_Type>{

    /**
     * The subject that can be used by implementations of this class to supply CRUD updates.
     */
    public readonly crudUpdateSubject:Subject<ListDataBrokerCRUDUpdate<D>> = new Subject();

    /**
     * Used to hold the list data in memory and also used to provide caching.
     */
    protected paginatedDataManager:PaginatedDataManager<D>;

    /**
     * emits the recent copies of a data to any party interested. This will be taken advantage of by the streamOne() method.
     */
    private readonly recentDataCopySubject = new Subject<ListDataBrokerUpdate<D>>();

    /**
     * @todo when dispose method is introduced, make sure this is unsubscribed to avoid memory leak.
     */
    private crudUpdatesSubscription:Subscription;

    /**
     * @param paginationOptions The paginatedDataManager options
     * @param idPropName the property name in a data that is used to get the data id
     * @param fetchOneResultAsLatest Whether the result returned by fetchOne() should be regarded as the most recent copy of that data 
     * which can be used to keep the child side consistent and optimized in operation.
     */
    constructor( paginationOptions:{perPage:number,append?:boolean} , private idPropName:string , private fetchOneResultAsLatest:boolean = true ){
        this.paginatedDataManager = new PaginatedDataManager<D>( paginationOptions.perPage , paginationOptions.append );

        this.handleCRUDUpdates().then();
    }

    async getData(): Promise<D[]> {
        return this.paginatedDataManager.data;
    }

    public getPaginationDataManager():PaginatedDataManager<D> {
        return this.paginatedDataManager;
    }

    /**
     * This will reflect crud updates on the in-mem list of data it manages.
     */
    private async handleCRUDUpdates(){
        this.crudUpdatesSubscription = this.streamCRUDUpdates().subscribe(( crudUpdate )=>{

            const { crudType , data } = crudUpdate;

            this.reflectDataIntoPaginatedDataManager( crudType, data );
        });
    }

    /**
     * This will update the data in the paginatedDataManager based on a type of CRUD operation
     * 
     * @param crudType The crud Type
     * @param data The data that will be reflect
     */
    protected reflectDataIntoPaginatedDataManager(crudType:CRUD , data:D ){
        const type = this.CRUDTypeToString(crudType);
        PaginatedDataManager.reflectDataIntoPaginatedDataManager<D>( this.paginatedDataManager , type as any , data , this.getComparator() );
    }

    private CRUDTypeToString(crudType:CRUD){
        return crudType == CRUD.CREATE ? 'create' : crudType == CRUD.UPDATE ? 'update' : crudType == CRUD.READ ? 'read' : 'delete' ;
    }

    /**
     * This method can be used to keep track of the most recent copy of a single data. Hence if a data has been updated,
     * the child side can use this method to be notified by the parent side of the latest copy.
     * 
     * @param options the options that can be used to load the single data
     * @returns an observable that keeps emiting newer copies of the data
     */
    public streamOne( options: ListDataBrokerLoadOneOptions ): Observable<ListDataBrokerUpdate<D>> {

        const id = options.id;

        const data$ = from(this.loadOne( options )).pipe( map( result => {
            const updateResult:ListDataBrokerUpdate<D> = this.createListDataBrokerUpdate( result.data );
            return updateResult;
        } ) );

        return concat( data$ , merge( this.recentDataCopySubject.asObservable() , 
        this.streamCRUDUpdates() ).pipe( switchMap( (update) => {
            if( update.crudType == CRUD.UPDATE && update.data[this.idPropName] == id ){
                const updateResult:ListDataBrokerUpdate<D> = this.createListDataBrokerUpdate(update.data) ;
                return of( updateResult );
            }
            return EMPTY;
        } ) ) );
    }

    public getComparator():DATA_COMPARATOR<D>{
        return ObjectUtils.getObjectPropComparator( this.idPropName , "number" );
    }
 
    private createListDataBrokerResult<T>( data:T ):ListDataBrokerResult<T>{
        return { data };
    }

    private createListDataBrokerUpdate( data:D ):ListDataBrokerResult<D>{
        return { data };
    }

    /**
     * @returns an observable that keeps emiting CRUD updates so the client side can hold consistent information
     */
    public streamCRUDUpdates(): Observable<ListDataBrokerCRUDUpdate<D>>{
        return this.crudUpdateSubject.asObservable();
    }

    /**
     * @param options the options that can be used to load the single data from a cache or data source
     * @returns an object that contains the single data
     */
    async loadOne(options: ListDataBrokerLoadOneOptions): Promise<ListDataBrokerResult<D>> {
        
        if(options.checkCache){

            const data = this.paginatedDataManager.data.find( datium => datium[this.idPropName] == options.id );

            if( data ) return this.createListDataBrokerResult<D>(data);
        }

        const fetchResult = await this.fetchOne( options );

        if( this.fetchOneResultAsLatest ){
            const newData = fetchResult.data;
    
            ObjectUtils.modifyObj( this.paginatedDataManager.data , newData , OBJ_MODIFY_APPROACH.SET_IN_ARRAY , 
                this.getComparator() );

            this.recentDataCopySubject.next( this.createListDataBrokerUpdate(newData) );
        }

        return fetchResult;
    }

    /**
     * @param options the options that can be used to load the array of data from a cache or data source
     * @returns an object that contains an array of data
     */
    async load( options : ListDataBrokerLoadOptions ): Promise<ListDataBrokerResult<D[]>> {

        const nextPage = this.paginatedDataManager.nextPage;
        const page = options.page;

        /**
         * @todo this should be removed when the paginatedDatamanager is improved to handle an arbitrary batch.
         */
        if( page > nextPage ){
            throw new Error( `Only a page that is less than or equal to the nextPage can be fetched` );
        }

        if( this.paginatedDataManager.batchExists(page) && options.checkCache ){
            return this.createListDataBrokerResult<D[]>( this.paginatedDataManager.getBatch(page) );
        }
        
        const fetchResult = await this.fetch( options ).then(( result )=>{
            return Promise.resolve(result);
        });
        
        if( page == nextPage ){
            this.paginatedDataManager.addNextBatch( fetchResult.data );
        }

        return fetchResult;
    }

    public async emitCRUDEvent( crudType:CRUD , data?:U|D ):Promise<D>{

        const normalizedData = await this.onCRUD(crudType,data);

        this.reflectDataIntoPaginatedDataManager(crudType,normalizedData);

        this.recentDataCopySubject.next( this.createListDataBrokerUpdate(normalizedData) );

        return normalizedData;
    }

    // CHECK PARENT INTERFACE FOR DOCUMENTATION
    abstract getConfig(): ListDataBrokerConfig;
    abstract canCRUD(crudType: CRUD): Promise<boolean> ;
    abstract onCRUD(crudType: CRUD, data?: U|D): Promise<D> ;
    abstract on(ev: DataBrokerEvent<EV_Type>): Promise<any> ;
    //

    /**
     * @param options the options that can be used to fetch the data from a data source
     * @returns an object that contains the data
     */
    abstract fetchOne(options: ListDataBrokerLoadOneOptions): Promise<ListDataBrokerResult<D>>;
    
    /**
     * @param options the options that can be used to fetch the data from a data source
     * @returns an object that contains the array of data
     */
    abstract fetch(options: ListDataBrokerLoadOptions): Promise<ListDataBrokerResult<D[]>>;
}
